//! Build Steps

use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::io::Write;

pub struct BuildContext<'s> {
    pub cradle_directory: PathBuf,
    cradle_name: &'s str
}
impl<'s> BuildContext<'s> {
    pub fn new(cradle_name: &'s str) -> Self {
        Self {
            cradle_name,
            cradle_directory: crate::platform::cradle_directory().join(cradle_name)
        }
    }

    pub fn print_step(&self, text: &str) {
        println!(
            " {} [{}] {}",
            console::style("*").fg(console::Color::Green).bold(),
            console::style(self.cradle_name).fg(console::Color::White).bright(),
            text
        );
    }
    pub fn cwd_cradle_dir(&self) {
        std::env::set_current_dir(&self.cradle_directory).expect("Failed to change current directory");
    }
    pub fn within_cradle_dir<F: FnOnce()>(&self, exec: F) {
        let org_directory = std::env::current_dir().expect("Failed to get current working directory");
        self.cwd_cradle_dir();

        exec();

        std::env::set_current_dir(org_directory).expect("Failed to rollback org directory");
    }
}

pub fn gen_manifest(ctx: &BuildContext, userlib_path: &Path, userlib_name: &str, features: Vec<&str>) {
    ctx.print_step("Generating manifest...");

    crate::manifest::gen_manifest(
        &ctx.cradle_directory.join("Cargo.toml"),
        &ctx.cradle_directory.join("Cargo.template.toml"),
        &std::fs::canonicalize(userlib_path).expect("Failed to canonicalize userlib path"),
        userlib_name,
        features
    );
}
pub fn gen_userlib_import_code(ctx: &BuildContext, userlib_name: &str, entry_ty_name: &str) {
    ctx.print_step("Generating Userlib Entry code...");

    let mut w = std::fs::OpenOptions::new().create(true).truncate(true).write(true)
        .open(ctx.cradle_directory.join("src/userlib.rs"))
        .expect("Failed to open userlib.rs");
    writeln!(
        w,
        "//! Auto Generated by Build script\n\npub use {}::{} as Game;",
        userlib_name.replace('-', "_"),
        entry_ty_name
    ).expect("Failed to write userlib.rs");
}
pub fn update_deps(ctx: &BuildContext) {
    ctx.print_step("Updating dependencies...");

    let e = std::process::Command::new("cargo")
        .args(&["update"])
        .spawn()
        .expect("Failed to spawn `cargo update`")
        .wait()
        .expect("Failed to wait `cargo update`");
    crate::shellutil::handle_process_result("`cargo update`", e);
}
pub fn cargo(
    ctx: &BuildContext, subcmd: &str, ext_features: Vec<&str>, env: HashMap<&str, &str>, target_spec: Option<&str>
) {
    ctx.print_step("Compiling code...");

    let ext_features = ext_features.join(",");
    let mut cmd = std::process::Command::new("cargo");
    cmd.arg(subcmd).envs(env);
    if let Some(t) = target_spec {
        cmd.args(&["--target", t]);
    }
    if !ext_features.is_empty() {
        cmd.args(&["--features", &ext_features]);
    }
    let e = cmd
        .spawn()
        .expect("Failed to spawn cargo build command")
        .wait()
        .expect("Failed to wait cargo build command");
    crate::shellutil::handle_process_result("cargo build command", e);
}

/*
pub fn run_steps<'s>(cradle_subdirectory_path: &str, steps: impl Iterator<Item = BuildStep<'s>>) {
    let cradle_directory = crate::platform::cradle_directory().join(cradle_subdirectory_path);

    for s in steps {
        match s {
            BuildStep::GenAndroidFiles { appid, asset_path } => {
                print_step(cradle_subdirectory_path, format_args!("Generating Android build files..."));

                let android_app_base = cradle_directory.join("apkbuild/app");
                let c = std::fs::read_to_string(android_app_base.join("build-template.gradle"))
                    .expect("Failed to read template gradle script");
                let c = c.replace("**APKAPPID**", &format!("'{}'", appid));
                let c = c.replace(
                    "**ASSETDIR**",
                    std::fs::canonicalize(asset_path)
                        .expect("Failed to canonicalize asset path")
                        .to_str()
                        .expect("invalid sequence in asset path")
                );
                std::fs::write(android_app_base.join("build.gradle"), c).expect("Failed to write gradle script");

                let c = std::fs::read_to_string(android_app_base.join("src/main/AndroidManifest-template.xml"))
                    .expect("Failed to read template android manifest");
                let c = c.replace("**APKAPPID**", appid);
                std::fs::write(android_app_base.join("src/main/AndroidManifest.xml"), c)
                    .expect("Failed to write android manifest");
            },
            BuildStep::MergeAndroidResourceDirectory { resource_path } => {
                print_step(cradle_subdirectory_path, format_args!("Merging Customized resource directories..."));

                let target_path = cradle_directory.join("apkbuild/app/src/main/res");
                // Make default structure then mirrors the user-defined structure,
                // results an user-customized resource structure
                handle_process_result(
                    "default sync command",
                    sh_mirror(
                        &cradle_directory.join("apkbuild/app/src/main/res-default"),
                        &target_path,
                        &[]
                    ).expect("Failed to run default mirror command")
                );
                if resource_path.exists() {
                    handle_process_result(
                        "appending copy command",
                        sh_append_copy(resource_path, &target_path).expect("Failed to run appending copy command")
                    );
                }
            },
            BuildStep::MirrorAndroidExtLibraries { extlib_path } => {
                print_step(cradle_subdirectory_path, format_args!("Mirroring External libraries..."));

                if extlib_path.exists() {
                    let target_path = cradle_directory.join("apkbuild/app/src/main/jniLibs");
                    handle_process_result(
                        "sync command",
                        sh_mirror(extlib_path, &target_path, &[".*"]).expect("Failed to run mirror command")
                    );
                }
            }
        }
    }
}
*/
