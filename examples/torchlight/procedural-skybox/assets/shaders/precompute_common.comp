
const float H_ATM = 80000;
const float R_EARTH = 6371000;
const vec3 RayleighCoeffs = vec3(6.55e-6, 1.73e-5, 2.30e-5);
const vec3 MieCoeffs = vec3(2e-6, 2e-6, 2e-6);
const vec3 TransmittanceMieCoeffs = MieCoeffs / 0.9;

vec3 calcTransmittanceFromDensities(float mieDensity, float rayleighDensity)
{
    return exp(-(TransmittanceMieCoeffs * mieDensity + RayleighCoeffs * rayleighDensity));
}

// Inverse Parameterizations //
float calcHeightFromParam(float uh) { return pow(uh, 2.0) * H_ATM; }
float calcViewZenithCosFromParam(float uv, float h)
{
    const float ch = -sqrt(h * (2.0 * R_EARTH + h)) / (R_EARTH + h);
    return uv > 0.5f ? (ch + pow(uv - 0.5, 5.0) * (1.0 - ch)) : (ch - pow(uv, 5) * (1.0 + ch));
}
float calcSunZenithCosFromParam(float us)
{
    return tan((2.0 * us - 1.0 + 0.26) * 0.75) / tan(1.26 * 0.75);
}

// Parameterizations //
float parameterizeHeight(float h) { return sqrt(h / H_ATM); }
float parameterizeViewZenithCos(float cv, float h)
{
    const float ch = -sqrt(h * (2.0 * R_EARTH + h)) / (R_EARTH + h);
    return cv > ch ? (0.5 + 0.5 * pow((cv - ch) / (1.0 - ch), 0.2)) : (0.5 * pow((ch - cv) / (ch + 1.0), 0.2));
}
float parameterizeSunZenithCos(float cs)
{
    return 0.5 * ((1.0 - 0.26) + (atan(max(cs, -0.1975) * tan(1.26 * 1.1)) / 1.1));
}

// unit: m
const float RayleighScaleHeight = 8000;
const float MieScaleHeight = 1200;
float density(float h, float scale)
{
    return exp(-h / scale);
}
float getRayleighDensity(float h) { return density(h, RayleighScaleHeight); }
float getMieDensity(float h) { return density(h, MieScaleHeight); }

float height(vec2 p) { return length(p) - R_EARTH; }
// true if intersects with ground of the earth
bool intersection(vec2 p, vec2 v, out vec2 pa)
{
    // length(p + v * t) = R_EARTH
    // sqrt(dot(p.xy + v.xy * t, p.xy + v.xy * t)) = R_EARTH
    // sqrt((p.x + v.x * t)^2 + (p.y + v.y * t)^2) = R_EARTH
    // sqrt((p.x + v.x * t)^2 + (p.y + v.y * t)^2) = sqrt((a + bt)^2 + (c + dt)^2) = sqrt(a^2 + 2abt + (bt)^2 + c^2 + 2cdt + (dt)^2)
    // = sqrt(a^2 + c^2 + 2t(ab + cd) + (bt^2) + (dt)^2) = sqrt(a^2 + c^2 + 2t(ab + cd) + (t^2)(b^2 + d^2))
    // (t^2)(b^2 + d^2) + 2t(ab + cd) + a^2 + c^2 - R_EARTH^2 = 0
    // xt^2 + yt + z = 0 where x = dot(v, v), y = 2*dot(p, v), z = dot(p, p) - R_EARTH^2
    // t = (-y + sqrt(y^2 - 4xz)) / 2x | (-y - sqrt(y^2 - 4xz)) / 2x

    const float x = dot(v, v);
    const float y = 2 * dot(p, v);
    const float zAtmos = dot(p, p) - pow(R_EARTH + H_ATM, 2);
    const float zGround = dot(p, p) - pow(R_EARTH, 2);
    const float tAtmosPos = (-y + sqrt(y * y - 4.0 * x * zAtmos)) / (2.0 * x);
    const float tAtmosNeg = (-y - sqrt(y * y - 4.0 * x * zAtmos)) / (2.0 * x);
    const float tAtmos = tAtmosPos >= 0 ? (tAtmosNeg >= 0 ? min(tAtmosPos, tAtmosNeg) : tAtmosPos) : tAtmosNeg;

    const float tGroundDiscriminant = y * y - 4.0 * x * zGround;
    if (tGroundDiscriminant < 0)
    {
        pa = p + v * tAtmos;
        return false;
    }
    else
    {
        const float tPos = (-y + sqrt(tGroundDiscriminant)) / (2.0 * x);
        const float tNeg = (-y - sqrt(tGroundDiscriminant)) / (2.0 * x);
        const float t = tPos >= 0 ? (tNeg >= 0 ? min(tPos, tNeg) : tPos) : tNeg;
        pa = p + v * (t >= 0.0 ? t : tAtmos);
        return t >= 0.0;
    }
}
