//! impl 4.4

#version 450

const uint IntegrationSteps = 128;
layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba16f) writeonly uniform image2D transmittanceLUT;

#include "precompute_common.comp"

void main()
{
    const vec2 uv = (gl_GlobalInvocationID.xy * 0.9 + 0.5) / vec2(imageSize(transmittanceLUT));
    // Inverse Parameterization
    const float observerHeight = calcHeightFromParam(uv.y);
    const float sunZenithCos = calcSunZenithCosFromParam(uv.x);

    const vec2 observerPos = vec2(0.0f, R_EARTH + observerHeight);
    // sin^2 + cos^2 = 1
    // sin^2 = 1 - cos^2
    // sin = sqrt(1 - cos^2)
    const vec2 dir = vec2(sqrt(1.0 - pow(sunZenithCos, 2.0)), sunZenithCos);
    vec2 pBound;
    const bool hasGroundIntersection = intersection(observerPos, dir, pBound);

    const float stepSize = length(pBound - observerPos) / float(IntegrationSteps);
    vec2 lastDensity = vec2(0.0);
    vec2 totalDensity = vec2(0.0);
    for (uint i = 0; i < IntegrationSteps; i++)
    {
        const vec2 s = observerPos + dir * (stepSize * float(i));
        const vec2 currentDensity = vec2(getMieDensity(height(s)), getRayleighDensity(height(s)));
        totalDensity += (currentDensity + lastDensity) * 0.5 * stepSize;
        lastDensity = currentDensity;
    }
    const vec3 transmittance = calcTransmittanceFromDensities(totalDensity.x, totalDensity.y);

    imageStore(transmittanceLUT, ivec2(gl_GlobalInvocationID.xy), hasGroundIntersection ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(transmittance, 1.0));
}
