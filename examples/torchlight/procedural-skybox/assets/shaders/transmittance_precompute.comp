//! impl 4.4

#version 450

const uint IntegrationSteps = 128;
layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba16f) writeonly uniform image2D transmittanceLUT;

#include "precompute_common.comp"

void main()
{
    const vec2 uv = gl_GlobalInvocationID.xy / vec2(imageSize(transmittanceLUT));
    // Inverse Parameterization
    const float observerHeight = calcHeightFromParam(uv.y);
    const float sunZenithCos = calcSunZenithCosFromParam(uv.x);

    const vec2 observerPos = vec2(0.0f, R_EARTH + observerHeight);
    // sin^2 + cos^2 = 1
    // sin^2 = 1 - cos^2
    // sin = sqrt(1 - cos^2)
    const vec2 dir = vec2(sqrt(1.0 - pow(sunZenithCos, 2.0)), sunZenithCos);
    vec2 pBound;
    const bool hasGroundIntersection = intersection(observerPos, dir, pBound);

    const float stepSize = length(pBound - observerPos) / float(IntegrationSteps);
    float lastDensityMie = getMieDensity(observerPos.y);
    float lastDensityRayleigh = getRayleighDensity(observerPos.y);
    float totalDensityMie = 0.0;
    float totalDensityRayleigh = 0.0;
    for (uint i = 0; i < IntegrationSteps; i++)
    {
        const vec2 s = observerPos + dir * (stepSize * i);
        const float currentDensityMie = getMieDensity(height(s));
        const float currentDensityRayleigh = getRayleighDensity(height(s));
        totalDensityMie += (currentDensityMie + lastDensityMie) * 0.5 * stepSize;
        totalDensityRayleigh += (currentDensityRayleigh + lastDensityRayleigh) * 0.5 * stepSize;
        lastDensityMie = currentDensityMie;
        lastDensityRayleigh = currentDensityRayleigh;
    }
    const vec3 transmittance = calcTransmittanceFromDensities(totalDensityMie, totalDensityRayleigh);

    imageStore(transmittanceLUT, ivec2(gl_GlobalInvocationID.xy), hasGroundIntersection ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(transmittance, 1.0));
}
